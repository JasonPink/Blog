## 前言
    对JavaScript实现继承的方式做一些记录与分析
***
### 1.原型链继承
```
    function Parent() {
        this.name = 'Jason';
    }

    Parent.prototype.getName = function() {
        console.log(this.name);
    }

    function Child() {
        
    }

    Child.prototype = new Parent(); // 子类的原型对象指向父类的实例

    var child1 = new Child();

    console.log(child1.getName()) // Jason
```
缺点：
1. 引用类型的属性被所有实例共享
2. 无法传递参数、无法实现多继承
***
### 2.借用构造函数(经典继承)
```
    function Parent() {
        this.names = ['Jason', 'Pink']
    }

    function Child() {
        Parent.call(this); // 在子类中重新运行父类的方法
    }

    var child1 = new Child();

    child1.names.push('Lufei');

    console.log(child1.names); // ['Jason', 'Pink', 'Lufei']

    var child2 = new Child();

    console.log(child2.names); // ['Jason', 'Pink']
```
优点：
1. 可以传递参数，可以实现多继承
2. 避免了引用类型的属性被所有实例共享

缺点： 
1. 创建出来的实例只属于Child,而不属于Parent(instanceof)
2. 只能继承Parent构造函数的属性和方法,无法继承Parent.prototype上的属性和方法
3. 每次创建实例都会将构造函数上的方法创建一遍
***
### 3.组合继承(原型链继承+借用构造函数)
```
    function Parent(name) {
        this.name = name;
        this.fruits = ['apple', 'pear', 'peach'];
    }

    Parent.prototype.getName = function() {
        console.log(this.name)
    }

    function Child(name, age) {
        this.age = age;
        Parent.call(this, name); 
    }

    Child.prototype = new Parent();
    Child.prototype.constructor = Child;

    var child1 = new Child('Jason', 22);
```
缺点： Parent的构造函数被调用了两次, Parent构造函数的属性在实例和原型中同时存在(占用内存)
***
### 4.原型式继承
    将传入的对象作为创建的对象的原型(Object.create的模拟实现)
```
    function createObj(obj) {
        function F() {};
        F.prototype = obj;
        return new F();
    }
```
缺点： 引用类型的值始终会被共享
***
### 5.寄生组合式继承
    在组合继承的基础上加以改进，解决了组合继承出现的问题(父类的构造函数被调用了两次)
    第一次是在子类中Parent.call(this), 为了可以传递参数,所以这里必然要调用一次
    第二次是在Child.prototype = new Parent()时触发的,我们写这行代码的主要目的其实是想访问到Parent.prototype,
    那有没有办法可以既访问到Parent.prototype,又不用实例化Parent呢？有, 我们可以用一个空的函数来做跳转来达到我们的目的
```
    function Parent(name) {
        this.name = name;
        this.fruits = ['apple', 'pear', 'peach'];
    }

    Parent.prototype.getName = function() {
        console.log(this.name)
    }

    function Child(name, age) {
        this.age = age;
        Parent.call(this, name); 
    }

    var F = function () {};

    F.prototype = Parent.prototype;

    Child.prototype = new F();

    var child1 = new Child('Jason', 22);
```
    最后引用红宝书中的话：这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。
    与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式