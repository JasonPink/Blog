## 前言

***
## 实现继承的方法
1. ###原型链继承
```
    function Parent() {
        console.log('这是父类');
    }

    function Child() {
        console.log('这是子类')
    }

    Child.prototype = new Parent(); //子类的原型对象指向父类的实例

    优点： 使用简单一行代码实现、在子类的prototype上增加属性和方法不会影响到父类
    缺点：无法实现多继承、所有的属性都是共享的、无法传递参数
```
***
2. ###借用构造函数式继承
```
    function Parent(name, age) {
        console.log('这是父类');
        this.name = name;
        this.age = age;
    }

    function Child(name, age) {
        console.log('这是子类');
        Parent.call(this, name, age); //在子类中重新运行父类的方法
    }

    优点： 可以实现多继承、可以传递参数
    缺点：创建出来的实例只是子类的实例而不是父类的实例(instanceOf)、只能继承构造函数中的属性和方法，不能继承原型上的属性和方法、无法复用属性与方法
```
3. ###组合式继承(伪经典继承)
```
    function Parent(name, age) {
        console.log('这是父类');
        this.name = name;
        this.age = age;
    }

    function Child(name, age) {
        console.log('这是子类');
        Parent.call(this, name, age); 
    }

    Child.prototype = new Parent();
    Child.prototype.constructor = Child;

    缺点：
        父类的构造函数被调用了两次、父类的属性在实例和原型中同时存在(影响内存)
```
4. ###经典继承
```
    function Parent(name, age) {
        console.log('这是父类');
        this.name = name;
        this.age = age;
    }

    function Child(name, age) {
        console.log('这是子类');
        Parent.call(this, name, age); 
    }

    const f = function() {};
    f.prototype = Parent.prototype;
    Child.prototype = new f();

    Child.prototype.constructor = Child;
```