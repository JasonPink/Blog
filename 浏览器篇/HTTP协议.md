## HTTP/0.9
> HTTP/0.9是于1991年提出的，需求很简单————用来在网络之间传递HTML超文本的内容，所以被称为**超文本传输协议**。基于请求响应的模式，从客户端发出请求，服务端返回数据。
### 一个完整的请求流程
+ 建立TCP连接，因为HTTP都是基于TCP协议的，所以客户端先要根据IP地址，端口号和服务器建立TCP连接，三次握手的过程
+ 建立好连接后，会发送一个GET请求行的信息，如GET/index.html用来获取index.html
+ 服务器接收请求信息后，读取对应的HTML文件，并将数据以ASCII字符流返回给客户端
+ HTML文档传输完成，断开连接
![事件循环](../assets/http09.png "HTTP0.9")
### 有以下三个特点
+ 只有一个请求行，没有HTTP请求头和请求体，因为只需要一个请求行就可以完整的表达客户端的需求了
+ 服务器也没有返回头信息，因为服务器并不需要告诉客户端太多信息，只需要返回数据就可以了
+ 返回的文件内容是以ASCII字符流来传输的,因为都是HTML格式的文件，所以使用ASCII字节码来传输是最合适的。
---
## HTTP/1.0
随着万维网的不断发展，带来了很多新的需求，而HTTP/0.9已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是HTTP/1.0诞生的原因

首先浏览器中展示的不单是HTML文件了，还包括了JavaScript、CSS、图片、音频、视频等不同类型的文件，因此**支持多种类型的文件下载是HTTP/1.0的一个核心诉求**

HTTP/1.0引入了请求头和响应头，它们都是以key-value形式保存的，在HTTP发送请求时，会带上请求头信息，服务器返回数据时，会返回响应头信息。

![事件循环](../assets/http10.png "HTTP1.0")

### HTTP/1.0怎么通过请求头和响应头来支持多种不同类型的数据
+ 首先，浏览器需要知道服务器返回的数据是什么类型，然后浏览器才能根据不同的数据类型做针对性的处理

+ 其次，为了减轻出书性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法

+ 再次，由于万维网是全球性的，所以需要提供国际化支持，服务器需要对不同的地区提供不同的语言版本

+ 最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型
```
accept: text/html //期望返回html类型的文件
accept-encoding: gzip, deflate, br //期望服务器采用gzip、deflate或br其中的一种压缩方式
accept-Charset: ISO-8859-1,utf-8 //期望返回的文件编码是utf-8或ISO-8859-1
accept-language: zh-CN,zh //期望页面的优先语言是中文
```
### 除了对多文件提供良好的支持外，还引入了很多其它特性
+ 有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器最终的处理情况，这就引入了状态码，状态码是通过响应行的方式来通知浏览器的
  + 2XX成功
      + 200 OK:表示从客户端发来的请求在服务器端被正确处理
      + 204 No content: 表示请求成功，但响应报文不含实体的主体部分
      + 206 Partial Content: 进行范围请求
  + 3XX重定向
      + 301 moved permanently: 永久性重定向，表示资源已被分配了新的URL
      + 302 found，临时性重定向，表示资源临时被分配了新的 URL
      + 303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源
      + 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
      + 307 temporary redirect，临时重定向，和302含义相同
  + 4XX客户端错误
      + 400 bad request，请求报文存在语法错误
      + 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
      + 403 forbidden，表示对请求资源的访问被服务器拒绝
      + 404 not found，表示在服务器上没有找到请求的资源
  + 5XX服务器错误
      + 500 internal sever error，表示服务器端在执行请求时发生了错误
      + 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

+ 为了减轻服务器的压力，在HTTP/1.0中提供了Cache机制

+ 服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。
---
## HTTP/1.1
> 不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。接下来我们来看看 HTTP/1.0 遇到了哪些主要的问题，以及 HTTP/1.1 又是如何改进的。

### 1.改进持久连接
  HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。为了解决这个问题，HTTP/1.1中增加了持久连接的方法，它的特点是在一个TCP上可以传输多个HTTP请求，只要浏览器或服务器没有明确的断开连接，那么该TCP连接会一直保持。

  持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。**目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。**

### 2.不成熟的HTTP管线化
  持久连接虽然能减少TCP的建立和连接次数，但是它需要等待前面的请求返回后，才能进行下一次请求。如果TCP通道中的某个请求没有及时返回，那么就会阻塞后面的所有请求，这就是著名的**对头阻塞**的问题。

### 3.提供虚拟主机的支持
  在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。

  因此，HTTP/1.1 的请求头中增加了**Host**字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

### 4.对动态生成的内容提供了完美支持

### 5.客户端Cookie、安全机制
---
## HTTP/2.0
### HTTP/1.1的主要问题：对带宽的利用率不理想
主要由以下三个原因导致：
1. TCP的慢启动

2. 同时开启了多条TCP连接,这些连接会竞争固定的带宽

3. HTTP/1.1对头阻塞问题
---
### 为了解决以上问题，引入HTTP/2协议：一个域名只使用一个TCP长连接和消除对头阻塞问题
![HTTP/2 的多路复用](../assets/http2.jpg "HTTP/2 的多路复用")
该图就是 HTTP/2 最核心、最重要且最具颠覆性的**多路复用机制**。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。

服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。

HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。

---
### 多路复用的实现
![HTTP/2 协议栈](../assets/http22.png "HTTP/2 协议栈")
+ 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。

+ 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。

+ 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。

+ 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。

+ 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。

+ 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
---
### HTTP/2其他特性
1. 可以设置请求的优先级

2. 服务器推送

3. 头部压缩
